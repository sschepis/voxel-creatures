<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Voxel Creatures Evolutionary Sim</title>
  <link rel="canonical" href="https://codepen.io/sschepis/pen/WbbVOpm">
  <link rel="stylesheet" href="https://public.codepenassets.com/css/normalize-5.0.0.min.css">
  <link rel='stylesheet' href='https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css'>
  <!-- CSS inlined from css/style.css -->
<style>
.voxel-container {
  width: 100%;
  height: 400px;
  position: relative;
  background: #1a202c;
  border-radius: 12px;
  overflow: hidden;
}

.gene-progress {
  transition: width 0.5s ease-in-out;
}

.creature-card {
  transition: all 0.3s ease;
  transform-style: preserve-3d;
}

.creature-card:hover {
  transform: translateY(-5px) scale(1.02);
  box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.3);
}

@keyframes pulse {
  0% {
    opacity: 0.6;
  }
  50% {
    opacity: 1;
  }
  100% {
    opacity: 0.6;
  }
}
.pulsing {
  animation: pulse 2s infinite;
}

/* Custom scrollbar */
::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

::-webkit-scrollbar-track {
  background: #2d3748;
}

::-webkit-scrollbar-thumb {
  background: #4a5568;
  border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
  background: #718096;
}

#three-container {
  width: 100%;
  height: 100%;
}

.stats-badge {
  background: rgba(0, 0, 0, 0.5);
  backdrop-filter: blur(5px);
  border-radius: 4px;
}
</style>
</head>

<body class="bg-gray-900 text-white min-h-screen">
  <!-- Background Effect -->
  <div id="vanta-bg" class="fixed w-full h-full top-0 left-0 z-0"></div>

  <div class="relative z-10 container mx-auto px-4 py-8">
    <!-- Header section -->
    <!-- Begin components/header.html -->
<!-- Header -->
<header class="text-center mb-12">
  <h1 class="text-5xl font-bold mb-4 bg-clip-text text-transparent bg-gradient-to-r from-teal-400 to-blue-500">
    Voxel Creatures Evolutionary Sim
  </h1>
  <p class="text-xl text-gray-300 max-w-3xl mx-auto">
    Watch voxel creatures evolve with physics-based movement, environmental interactions, and complex behaviors.
  </p>
</header>
<!-- End components/header.html -->

    <!-- Main Simulation Area -->
    <div class="grid grid-cols-1 lg:grid-cols-3 gap-8 mb-12">
      <!-- Controls panel -->
      <!-- Begin components/controls.html -->
<!-- Left Panel - Controls -->
<div class="bg-gray-800 bg-opacity-80 rounded-xl p-6 shadow-xl backdrop-blur-sm">
  <h2 class="text-2xl font-semibold mb-4 border-b border-gray-700 pb-2 flex items-center">
    <i class="fas fa-sliders-h mr-2 text-teal-400"></i>
    Simulation Controls
  </h2>

  <div class="space-y-6">
    <div>
      <label class="block text-sm font-medium mb-1">Environment Type</label>
      <select id="environment-type" class="w-full bg-gray-700 border border-gray-600 rounded-md py-2 px-3 focus:outline-none focus:ring-2 focus:ring-teal-500">
        <option value="plains">Plains (balanced)</option>
        <option value="ocean">Ocean (swimming focus)</option>
        <option value="mountains">Mountains (climbing/strength)</option>
        <option value="desert">Desert (heat resistance)</option>
        <option value="forest">Forest (camouflage)</option>
        <option value="predators">Predators (speed/strength)</option>
      </select>
    </div>

    <div class="grid grid-cols-2 gap-4">
      <div>
        <label class="block text-sm font-medium mb-1">Population Size</label>
        <input type="range" id="population-size" min="5" max="30" value="12" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
        <div class="flex justify-between text-xs text-gray-400 mt-1">
          <span>5</span>
          <span>30</span>
        </div>
      </div>

      <div>
        <label class="block text-sm font-medium mb-1">Mutation Rate</label>
        <input type="range" id="mutation-rate" min="1" max="10" value="4" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
        <div class="flex justify-between text-xs text-gray-400 mt-1">
          <span>1%</span>
          <span>10%</span>
        </div>
      </div>
    </div>

    <div class="grid grid-cols-2 gap-4">
      <div>
        <label class="block text-sm font-medium mb-1">Food Amount</label>
        <input type="range" id="food-amount" min="1" max="10" value="5" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
        <div class="flex justify-between text-xs text-gray-400 mt-1">
          <span>Sparse</span>
          <span>Abundant</span>
        </div>
      </div>

      <div>
        <label class="block text-sm font-medium mb-1">Physics Accuracy</label>
        <input type="range" id="physics-accuracy" min="1" max="5" value="3" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
        <div class="flex justify-between text-xs text-gray-400 mt-1">
          <span>Low</span>
          <span>High</span>
        </div>
      </div>
    </div>

    <div class="flex space-x-3">
      <button id="start-btn" class="flex-1 bg-teal-600 hover:bg-teal-500 text-white py-2 px-4 rounded-md font-medium transition flex items-center justify-center">
        <i class="fas fa-play mr-2"></i> Start Evolution
      </button>
      <button id="pause-btn" class="flex-1 bg-gray-600 hover:bg-gray-500 text-white py-2 px-4 rounded-md font-medium transition flex items-center justify-center">
        <i class="fas fa-pause mr-2"></i> Pause
      </button>
      <button id="reset-btn" class="flex-1 bg-red-600 hover:bg-red-500 text-white py-2 px-4 rounded-md font-medium transition flex items-center justify-center">
        <i class="fas fa-undo mr-2"></i> Reset
      </button>
    </div>

    <div class="pt-4 border-t border-gray-700">
      <h3 class="font-medium mb-2 flex items-center">
        <i class="fas fa-info-circle mr-2 text-blue-400"></i>
        Current Generation: <span id="generation-counter" class="ml-2 font-bold">0</span>
      </h3>
      <h3 class="font-medium mb-2 flex items-center">
        <i class="fas fa-bolt mr-2 text-yellow-400"></i>
        Top Fitness: <span id="fitness-score" class="ml-2 font-bold">0</span>
      </h3>
      <h3 class="font-medium mb-2 flex items-center">
        <i class="fas fa-utensils mr-2 text-green-400"></i>
        Food Available: <span id="food-count" class="ml-2 font-bold">0</span>
      </h3>
    </div>
  </div>
</div>
<!-- End components/controls.html -->
      
      <!-- 3D Viewer -->
      <!-- Begin components/viewer.html -->
<!-- Center Panel - 3D Viewer -->
<div class="lg:col-span-2 rounded-xl overflow-hidden shadow-xl">
  <div class="voxel-container relative" id="three-container">
    <div id="stats-overlay" class="absolute z-10 bottom-0 left-0 right-0 p-4 bg-gradient-to-t from-black to-transparent hidden">
      <div class="text-white text-sm grid grid-cols-2 gap-2">
        <div>Speed: <span class="float-right" id="stat-speed">0</span></div>
        <div>Strength: <span class="float-right" id="stat-strength">0</span></div>
        <div>Size: <span class="float-right" id="stat-size">0</span></div>
        <div>Health: <span class="float-right" id="stat-health">0</span></div>
        <div>Energy: <span class="float-right" id="stat-energy">0</span></div>
        <div>Age: <span class="float-right" id="stat-age">0</span></div>
      </div>
    </div>
    <div id="loading-overlay" class="absolute inset-0 flex items-center justify-center bg-black bg-opacity-70">
      <div class="text-center">
        <i class="fas fa-spinner fa-spin text-4xl mb-4 text-teal-400"></i>
        <p class="text-xl">Loading physics engine...</p>
      </div>
    </div>
  </div>

  <div class="bg-gray-800 bg-opacity-80 p-4 border-t border-gray-700 backdrop-blur-sm">
    <div class="flex justify-between items-center">
      <div>
        <h3 class="font-medium">Selected: <span id="selected-creature" class="font-semibold text-teal-300">None</span></h3>
        <div class="flex space-x-2 mt-1">
          <span id="creature-age" class="stats-badge text-xs px-2 py-1">Age: 0</span>
          <span id="creature-fitness" class="stats-badge text-xs px-2 py-1">Fitness: 0</span>
          <span id="creature-generation" class="stats-badge text-xs px-2 py-1">Gen: 0</span>
          <span id="creature-species" class="stats-badge text-xs px-2 py-1">Species: New</span>
        </div>
      </div>
      <div class="flex space-x-2">
        <button id="breed-btn" class="bg-blue-600 hover:bg-blue-500 text-white py-1 px-3 rounded-md text-sm transition">
          <i class="fas fa-dna mr-1"></i> Breed
        </button>
        <button id="mutate-btn" class="bg-purple-600 hover:bg-purple-500 text-white py-1 px-3 rounded-md text-sm transition">
          <i class="fas fa-radiation mr-1"></i> Mutate
        </button>
        <button id="follow-btn" class="bg-green-600 hover:bg-green-500 text-white py-1 px-3 rounded-md text-sm transition">
          <i class="fas fa-eye mr-1"></i> Follow
        </button>
      </div>
    </div>
  </div>
</div>
<!-- End components/viewer.html -->
    </div>

    <!-- Population Grid -->
    <!-- Begin components/population.html -->
<!-- Population Grid -->
<div class="bg-gray-800 bg-opacity-80 rounded-xl p-6 shadow-xl backdrop-blur-sm mb-8">
  <h2 class="text-2xl font-semibold mb-4 border-b border-gray-700 pb-2 flex items-center">
    <i class="fas fa-users mr-2 text-blue-400"></i>
    Population <span class="ml-auto text-sm font-normal">(Click to select and track)</span>
  </h2>

  <div class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-6 gap-4" id="population-grid">
    <div class="text-center py-12 text-gray-500">
      <i class="fas fa-spinner fa-spin text-2xl mb-2"></i>
      <p>Initializing simulation...</p>
    </div>
  </div>
</div>
<!-- End components/population.html -->

    <!-- Stats and Genetics -->
    <!-- Begin components/stats.html -->
<!-- Stats and Genetics Panel -->
<div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
  <!-- Lineage Graph -->
  <div class="bg-gray-800 bg-opacity-80 rounded-xl p-6 shadow-xl backdrop-blur-sm">
    <h2 class="text-2xl font-semibold mb-4 border-b border-gray-700 pb-2 flex items-center">
      <i class="fas fa-project-diagram mr-2 text-purple-400"></i>
      Evolutionary Lineage
    </h2>
    <div class="h-64 overflow-x-auto overflow-y-hidden">
      <canvas id="lineage-chart" class="w-full h-full"></canvas>
    </div>
  </div>

  <!-- Genetic Traits -->
  <div class="bg-gray-800 bg-opacity-80 rounded-xl p-6 shadow-xl backdrop-blur-sm">
    <h2 class="text-2xl font-semibold mb-4 border-b border-gray-700 pb-2 flex items-center">
      <i class="fas fa-dna mr-2 text-red-400"></i>
      Genetic Traits Breakdown
    </h2>

    <div class="space-y-4">
      <div>
        <div class="flex justify-between mb-1">
          <span class="text-sm font-medium">Speed Gene</span>
          <span class="text-xs text-gray-400" id="speed-value">0%</span>
        </div>
        <div class="w-full bg-gray-700 rounded-full h-2">
          <div id="speed-bar" class="gene-progress bg-blue-500 h-2 rounded-full" style="width: 0%"></div>
        </div>
      </div>

      <div>
        <div class="flex justify-between mb-1">
          <span class="text-sm font-medium">Strength Gene</span>
          <span class="text-xs text-gray-400" id="strength-value">0%</span>
        </div>
        <div class="w-full bg-gray-700 rounded-full h-2">
          <div id="strength-bar" class="gene-progress bg-red-500 h-2 rounded-full" style="width: 0%"></div>
        </div>
      </div>

      <div>
        <div class="flex justify-between mb-1">
          <span class="text-sm font-medium">Size Gene</span>
          <span class="text-xs text-gray-400" id="size-value">0%</span>
        </div>
        <div class="w-full bg-gray-700 rounded-full h-2">
          <div id="size-bar" class="gene-progress bg-green-500 h-2 rounded-full" style="width: 0%"></div>
        </div>
      </div>

      <div>
        <div class="flex justify-between mb-1">
          <span class="text-sm font-medium">Health Gene</span>
          <span class="text-xs text-gray-400" id="health-value">0%</span>
        </div>
        <div class="w-full bg-gray-700 rounded-full h-2">
          <div id="health-bar" class="gene-progress bg-yellow-500 h-2 rounded-full" style="width: 0%"></div>
        </div>
      </div>

      <div>
        <div class="flex justify-between mb-1">
          <span class="text-sm font-medium">Behavior</span>
          <span class="text-xs text-gray-400" id="behavior-type">Passive</span>
        </div>
        <div class="w-full bg-gray-700 rounded-full h-2">
          <div id="behavior-bar" class="gene-progress bg-indigo-500 h-2 rounded-full" style="width: 0%"></div>
        </div>
      </div>

      <div>
        <div class="flex justify-between mb-1">
          <span class="text-sm font-medium">Specialization</span>
          <span class="text-xs text-gray-400" id="specialization">None</span>
        </div>
        <div class="w-full bg-gray-700 rounded-full h-2">
          <div id="specialization-bar" class="gene-progress bg-gradient-to-r from-purple-500 to-pink-500 h-2 rounded-full" style="width: 0%"></div>
        </div>
      </div>
    </div>
  </div>
</div>
<!-- End components/stats.html -->

    <!-- Footer -->
    <!-- Begin components/footer.html -->
<!-- Footer -->
<footer class="mt-12 text-center text-gray-500 text-sm">
  <p>Voxel Creatures Evolutionary Simulator â€¢ Physics-based evolution simulation with Three.js and Cannon.js</p>
  <p class="mt-2"><i class="fas fa-code-branch mr-1"></i> Press <kbd class="px-2 py-1 bg-gray-800 rounded text-xs">Space</kbd> to pause/resume | <kbd class="px-2 py-1 bg-gray-800 rounded text-xs">F</kbd> to toggle follow mode</p>
</footer>
<!-- End components/footer.html -->
  </div>

  <!-- External Dependencies -->
  <script src='https://cdn.jsdelivr.net/npm/chart.js'></script>
  <script src='https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js'></script>
  <script src='https://cdn.jsdelivr.net/npm/vanta@0.5.24/dist/vanta.globe.min.js'></script>
  <script src='https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js'></script>
  <script src='https://cdn.tailwindcss.com'></script>
  
  <!-- Component Loader -->
  <!-- Script inlined: js/components-loader.js -->
  
  <!-- Application Scripts -->
  <!-- Script inlined: js/main.js -->

<!-- All JavaScript inlined below -->
<script>

/* File: js/components-loader.js */
// Component Loader - Dynamically loads HTML components into the page

document.addEventListener('DOMContentLoaded', async () => {
  // Identify all component placeholders
  const componentPlaceholders = document.querySelectorAll('[data-component]');
  
  // Load each component
  for (const placeholder of componentPlaceholders) {
    const componentPath = placeholder.getAttribute('data-component');
    try {
      const response = await fetch(componentPath);
      if (!response.ok) {
        throw new Error(`Failed to load component: ${componentPath}`);
      }
      
      const html = await response.text();
      placeholder.innerHTML = html;
      
      // Dispatch event after component is loaded (for any initialization code)
      placeholder.dispatchEvent(new CustomEvent('component-loaded'));
    } catch (error) {
      console.error(`Error loading component ${componentPath}:`, error);
      placeholder.innerHTML = `<div class="error">Failed to load component: ${componentPath}</div>`;
    }
  }
  
  // Dispatch event when all components are loaded
  document.dispatchEvent(new CustomEvent('components-loaded'));
});

/* File: js/main.js */

/* File: js/simulation.js */

// Simulation.js - Handles physics world and simulation mechanics

class Simulation {
  constructor(config = {}) {
    // Constants and settings
    this.WORLD_SIZE = config.worldSize || 30;
    this.FOOD_SIZE = config.foodSize || 1;
    this.FOOD_ENERGY = config.foodEnergy || 50;
    this.MAX_FOOD = config.maxFood || 30;
    
    // Physics parameters
    this.PHYSICS_STEP = 1 / 60;
    this.SUBSTEPS = config.physicsAccuracy || 3;
    
    // Simulation state
    this.world = null; // Cannon.js physics world
    this.scene = null; // Three.js scene
    this.camera = null; // Three.js camera
    this.renderer = null; // Three.js renderer
    this.creatures = [];
    this.foods = [];
    this.obstacles = []; // Environmental obstacles
    this.currentGeneration = 0;
    this.simulationRunning = false;
    this.lastTime = 0;
    this.selectedCreature = null;
    this.followedCreature = null;
    this.fitnessHistory = [];
    this.environmentType = config.environmentType || "plains";
    this.nextCreatureId = 0;
    this.speciesCount = 0;
    
    // Environmental factors
    this.environmentSettings = {
      terrain: config.terrain || "flat",
      temperature: config.temperature || "moderate",
      foodDistribution: config.foodDistribution || "uniform",
      predatorPressure: config.predatorPressure || "low",
      mutationStimulus: config.mutationStimulus || 1.0,
      competitionIntensity: config.competitionIntensity || 1.0
    };
    
    // Time-based dynamics
    this.environmentCycleTime = 0;
    this.environmentCycleDirection = 1;
    this.environmentCyclePeriod = 5000; // ms
    this.seasonalChanges = config.seasonalChanges || false;
    
    // Callbacks for UI updates
    this.callbacks = {
      onGenerationChange: config.onGenerationChange || (() => {}),
      onFitnessUpdate: config.onFitnessUpdate || (() => {}),
      onFoodCountUpdate: config.onFoodCountUpdate || (() => {}),
      onPopulationRender: config.onPopulationRender || (() => {}),
      onCreatureSelect: config.onCreatureSelect || (() => {}),
      onChartUpdate: config.onChartUpdate || (() => {})
    };
  }
  
  // Initialize physics world and Three.js scene
  initPhysicsWorld(container) {
    // Setup Cannon.js physics world
    this.world = new CANNON.World();
    this.world.gravity.set(0, -9.82, 0); // Earth gravity
    this.world.broadphase = new CANNON.NaiveBroadphase();
    this.world.solver.iterations = 10;

    // Create ground plane
    const groundShape = new CANNON.Plane();
    const groundBody = new CANNON.Body({ mass: 0 });
    groundBody.addShape(groundShape);
    groundBody.quaternion.setFromAxisAngle(
      new CANNON.Vec3(1, 0, 0),
      -Math.PI / 2
    );
    this.world.addBody(groundBody);

    // Setup Three.js scene
    this.scene = new THREE.Scene();
    this.scene.background = new THREE.Color(0x1a202c);

    // Add ambient light
    const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
    this.scene.add(ambientLight);

    // Add directional light
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(10, 20, 10);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.width = 2048;
    dirLight.shadow.mapSize.height = 2048;
    this.scene.add(dirLight);

    // Setup camera
    this.camera = new THREE.PerspectiveCamera(
      75,
      container.offsetWidth / container.offsetHeight,
      0.1,
      1000
    );
    this.camera.position.set(0, 15, 30);
    this.camera.lookAt(0, 0, 0);

    // Setup renderer
    this.renderer = new THREE.WebGLRenderer({ antialias: true });
    this.renderer.setSize(container.offsetWidth, container.offsetHeight);
    this.renderer.shadowMap.enabled = true;
    this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    container.innerHTML = "";
    container.appendChild(this.renderer.domElement);

    // Add grid helper
    const gridHelper = new THREE.GridHelper(this.WORLD_SIZE, this.WORLD_SIZE / 2);
    this.scene.add(gridHelper);

    // Add world bounds
    this.addWorldBounds();
    
    // Pass necessary static values to creature class
    import('./entities/VoxelCreature.js').then(VoxelCreatureModule => {
      VoxelCreatureModule.default.WORLD_SIZE = this.WORLD_SIZE;
      VoxelCreatureModule.default.nextCreatureId = this.nextCreatureId;
    });
  }

  // Add physical boundaries to world
  addWorldBounds() {
    // Create invisible walls around the world
    const wallMaterial = new CANNON.Material({
      friction: 0.3,
      restitution: 0.7
    });
    const wallShape = new CANNON.Box(new CANNON.Vec3(this.WORLD_SIZE / 2, 10, 1));

    // North wall
    const northWall = new CANNON.Body({ mass: 0 });
    northWall.addShape(wallShape);
    northWall.position.set(0, 5, -this.WORLD_SIZE / 2);
    this.world.addBody(northWall);

    // South wall
    const southWall = new CANNON.Body({ mass: 0 });
    southWall.addShape(wallShape);
    southWall.position.set(0, 5, this.WORLD_SIZE / 2);
    this.world.addBody(southWall);

    // West wall
    const westWall = new CANNON.Body({ mass: 0 });
    westWall.addShape(new CANNON.Box(new CANNON.Vec3(1, 10, this.WORLD_SIZE / 2)));
    westWall.position.set(-this.WORLD_SIZE / 2, 5, 0);
    this.world.addBody(westWall);

    // East wall
    const eastWall = new CANNON.Body({ mass: 0 });
    eastWall.addShape(new CANNON.Box(new CANNON.Vec3(1, 10, this.WORLD_SIZE / 2)));
    eastWall.position.set(this.WORLD_SIZE / 2, 5, 0);
    this.world.addBody(eastWall);
  }

  // Start the animation loop
  startAnimation() {
    const animate = (time) => {
      requestAnimationFrame(animate);
      
      // Update physics
      this.updatePhysics(time);
      
      // Update camera to follow creature
      if (this.followedCreature && this.followedCreature.body) {
        this.camera.position.lerp(
          new THREE.Vector3(
            this.followedCreature.body.position.x,
            this.followedCreature.body.position.y + 10,
            this.followedCreature.body.position.z + 20
          ),
          0.1
        );
        this.camera.lookAt(
          new THREE.Vector3(
            this.followedCreature.body.position.x,
            this.followedCreature.body.position.y + 5,
            this.followedCreature.body.position.z
          )
        );
      }
      
      // Render scene
      this.renderer.render(this.scene, this.camera);
    };
    
    animate();
  }

  // Update physics simulation
  updatePhysics(time) {
    if (!this.simulationRunning) return;
    
    // Update environment cycle time
    if (this.seasonalChanges) {
      this.environmentCycleTime += this.environmentCycleDirection;
      
      // Reverse direction at extremes
      if (this.environmentCycleTime >= this.environmentCyclePeriod ||
          this.environmentCycleTime <= 0) {
        this.environmentCycleDirection *= -1;
        
        // When cycle completes, possibly change environment factors
        if (this.environmentCycleTime >= this.environmentCyclePeriod) {
          if (Math.random() < 0.2) {
            this.applySeasonalEffect();
          }
        }
      }
    }
    
    // Spawn food periodically - adjusted by environment
    const foodSpawnRate = this.getFoodSpawnRate();
    if (this.foods.length < this.getMaxFoodCount() && Math.random() < foodSpawnRate) {
      this.spawnFood();
    }
    
    // Apply environmental effects to creatures
    this.applyEnvironmentalEffects();
    
    // Update creatures
    this.creatures.forEach((creature) => {
      if (creature.alive) {
        creature.makeDecision(time);
        creature.move(time);
        
        // Pass all foods to checkForCollisions for improved food finding
        creature.findFood(this.foods);
        creature.checkForCollisions();
        
        // Apply environment-specific effects to creature movement
        this.applyEnvironmentToCreature(creature, time);
        
        creature.updateVisualRepresentation();
        creature.calculateFitness(this.environmentType);
      }
    });
    
    // Update food visuals with animation
    this.foods.forEach((food) => {
      if (food.alive) {
        food.updateVisualRepresentation();
      }
    });
    
    // Update obstacles
    this.obstacles.forEach(obstacle => {
      if (obstacle.mesh && obstacle.body) {
        obstacle.mesh.position.copy(obstacle.body.position);
        obstacle.mesh.quaternion.copy(obstacle.body.quaternion);
      }
    });
    
    // Step physics world
    const deltaTime = time - this.lastTime;
    this.lastTime = time;
    
    if (deltaTime > 0) {
      this.world.step(this.PHYSICS_STEP, deltaTime, this.SUBSTEPS);
    }
    
    // Remove dead creatures
    this.cleanupDeadCreatures();
    
    // Check if should advance generation
    this.checkGenerationAdvance();
  }

  // Spawn new food in the environment
  spawnFood() {
    if (this.foods.length >= this.getMaxFoodCount()) return;
    
    import('./entities/Food.js').then(FoodModule => {
      const Food = FoodModule.default;
      const food = new Food(this.world, this.scene, this.WORLD_SIZE, this.FOOD_SIZE);
      this.foods.push(food);
      this.callbacks.onFoodCountUpdate(this.foods.length);
      
      // Add additional food-related environmental effects
      if (this.environmentSettings.foodDistribution === "clustered") {
        // Clustered food distribution: spawn additional food nearby
        if (Math.random() < 0.3) {
          const clusterSize = Math.floor(Math.random() * 3) + 1;
          const clusterRadius = 3;
          
          for (let i = 0; i < clusterSize; i++) {
            const angle = Math.random() * Math.PI * 2;
            const distance = Math.random() * clusterRadius;
            const offsetX = Math.cos(angle) * distance;
            const offsetZ = Math.sin(angle) * distance;
            
            const clusterFood = new Food(this.world, this.scene, this.WORLD_SIZE, this.FOOD_SIZE);
            
            // Position near original food
            clusterFood.body.position.x = food.body.position.x + offsetX;
            clusterFood.body.position.z = food.body.position.z + offsetZ;
            
            this.foods.push(clusterFood);
          }
          
          this.callbacks.onFoodCountUpdate(this.foods.length);
        }
      }
    });
  }

  // Get maximum allowed food based on settings
  getMaxFoodCount() {
    return Math.floor((this.MAX_FOOD * this.foodScale) / 10);
  }

  // Clean up dead creatures
  cleanupDeadCreatures() {
    const aliveCreatures = [];
    
    this.creatures.forEach((creature) => {
      if (creature.alive && creature.energy > 0) {
        aliveCreatures.push(creature);
      } else {
        // Remove physics bodies and visuals
        creature.removePhysicsBodies();
        creature.meshes.forEach((mesh) => this.scene.remove(mesh));
        
        // If this was the selected/followed creature, clear selection
        if (this.selectedCreature && this.selectedCreature.id === creature.id) {
          this.selectedCreature = null;
          this.callbacks.onCreatureSelect(null);
        }
        
        if (this.followedCreature && this.followedCreature.id === creature.id) {
          this.followedCreature = null;
        }
      }
    });
    
    this.creatures = aliveCreatures;
  }

  // Check if generation should advance
  checkGenerationAdvance() {
    // Advance generation when 80% of creatures have died
    const survivalThreshold = Math.max(3, this.creatures.length * 0.2);
    
    if (this.creatures.length <= survivalThreshold && this.simulationRunning) {
      this.nextGeneration();
    }
  }

  // Create the next generation of creatures
  nextGeneration() {
    // Evaluate fitness for all creatures in current environment
    this.creatures.forEach((creature) => creature.calculateFitness(this.environmentType));
    
    // Sort by fitness (descending)
    this.creatures.sort((a, b) => b.fitness - a.fitness);
    
    // Keep top performers (elitism) - environmental pressures affect selection rate
    const selectionPressure = this.getSelectionPressure();
    const keepCount = Math.max(3, Math.floor(this.creatures.length * selectionPressure));
    const nextGen = this.creatures.slice(0, keepCount);
    
    // Breed to fill population
    import('./entities/VoxelCreature.js').then(VoxelCreatureModule => {
      const VoxelCreature = VoxelCreatureModule.default;
      
      // Determine if any special breeding adaptations are needed
      const currentMutationRate = this.getAdjustedMutationRate();
      
      // Fill population - with occasional diversity boosts
      while (nextGen.length < this.populationSize) {
        // Special case: if too low diversity, create some random creatures
        if (this.checkLowDiversity() && Math.random() < 0.2) {
          // Add a fresh random creature to stimulate diversity
          const newRandomCreature = new VoxelCreature(null, this.currentGeneration, {
            world: this.world,
            scene: this.scene,
            WORLD_SIZE: this.WORLD_SIZE,
            nextCreatureId: this.nextCreatureId++,
            speciesCount: this.speciesCount++
          });
          nextGen.push(newRandomCreature);
        } else {
          // Select parents using fitness-proportionate selection
          const parent1 = this.selectParent();
          const parent2 = this.selectParent();
          
          if (parent1 && parent2) {
            // Apply environmental effects to mutation
            const child = parent1.breedWith(parent2, currentMutationRate);
            
            // For extreme environments, apply additional mutations
            if (this.isExtremeEnvironment() && Math.random() < 0.3) {
              child.mutate(currentMutationRate * 1.5);
            }
            
            nextGen.push(child);
          }
        }
      }
      
      // Reset mated status for new generation
      nextGen.forEach((creature) => (creature.mated = false));
      
      this.creatures = nextGen;
      this.currentGeneration++;
      
      // Change environment occasionally to force adaptation
      if (this.seasonalChanges && this.currentGeneration % 5 === 0) {
        this.cyclicEnvironmentChange();
      }
      
      this.callbacks.onGenerationChange(this.currentGeneration);
      this.callbacks.onPopulationRender();
      
      // Store fitness history
      const maxFitness = this.creatures[0]?.fitness || 0;
      this.fitnessHistory.push(maxFitness * 100);
      if (this.fitnessHistory.length > 15) {
        this.fitnessHistory.shift();
      }
      
      // Update fitness score
      this.callbacks.onFitnessUpdate(maxFitness);
      this.callbacks.onChartUpdate(this.fitnessHistory);
      
      // Show fittest creature
      if (this.creatures.length > 0) {
        this.selectCreature(this.creatures[0]);
      }
      
      // Spawn new food
      this.respawnFood();
      
      // Update obstacles and terrain features
      this.updateEnvironmentalObstacles();
    });
  }

  // Select parent based on fitness
  selectParent() {
    // Fitness proportionate selection
    const fitnessSum = this.creatures.reduce(
      (sum, creature) => sum + creature.fitness,
      0
    );
    const random = Math.random() * fitnessSum;
    let runningSum = 0;
    
    for (const creature of this.creatures) {
      runningSum += creature.fitness;
      if (runningSum >= random) {
        return creature;
      }
    }
    
    return this.creatures[0]; // fallback
  }

  // Respawn all food
  respawnFood() {
    // Remove all existing food
    this.foods.forEach((food) => {
      this.world.removeBody(food.body);
      this.scene.remove(food.mesh);
    });
    this.foods = [];
    
    // Spawn new food
    for (let i = 0; i < this.getMaxFoodCount(); i++) {
      this.spawnFood();
    }
  }

  // Initialize the simulation with creatures
  initSimulation(populationSize = 12) {
    this.clearPopulation();
    this.populationSize = populationSize;
    
    // Create initial population
    import('./entities/VoxelCreature.js').then(VoxelCreatureModule => {
      const VoxelCreature = VoxelCreatureModule.default;
      
      for (let i = 0; i < populationSize; i++) {
        const params = {
          world: this.world,
          scene: this.scene,
          WORLD_SIZE: this.WORLD_SIZE,
          nextCreatureId: this.nextCreatureId++,
          speciesCount: this.speciesCount++
        };
        
        this.creatures.push(new VoxelCreature(null, 0, params));
      }
      
      this.currentGeneration = 0;
      this.callbacks.onGenerationChange(this.currentGeneration);
      
      // Spawn initial food
      this.respawnFood();
      
      this.callbacks.onPopulationRender();
      this.callbacks.onChartUpdate(this.fitnessHistory);
      
      // Select a random creature
      if (this.creatures.length > 0) {
        this.selectCreature(this.creatures[Math.floor(Math.random() * this.creatures.length)]);
      }
    });
  }

  // Select a creature
  selectCreature(creature) {
    this.selectedCreature = creature;
    this.callbacks.onCreatureSelect(creature);
  }

  // Clear the population
  clearPopulation() {
    // Remove all creatures
    this.creatures.forEach((creature) => {
      creature.removePhysicsBodies();
      creature.meshes.forEach((mesh) => this.scene.remove(mesh));
    });
    
    this.creatures = [];
    this.foods = [];
    
    this.callbacks.onPopulationRender();
    this.selectedCreature = null;
    this.followedCreature = null;
    this.callbacks.onCreatureSelect(null);
    this.callbacks.onFitnessUpdate(0);
    this.fitnessHistory = [];
    this.callbacks.onChartUpdate(this.fitnessHistory);
    this.callbacks.onFoodCountUpdate(0);
  }

  // Set environment type
  setEnvironmentType(type) {
    this.environmentType = type;
    
    // Update environment appearance
    this.updateEnvironmentAppearance();
    
    // Recalculate all fitness scores
    this.creatures.forEach((creature) => creature.calculateFitness(this.environmentType));
    
    // Sort by new fitness
    this.creatures.sort((a, b) => b.fitness - a.fitness);
    
    // Update display if we have a selected creature
    if (this.selectedCreature) {
      this.callbacks.onCreatureSelect(this.selectedCreature);
    }
    
    this.callbacks.onPopulationRender();
    
    // Update environmental obstacles
    this.updateEnvironmentalObstacles();
  }

  // Set physics accuracy
  setPhysicsAccuracy(accuracy) {
    this.SUBSTEPS = accuracy;
  }

  // Set food amount
  setFoodAmount(scale) {
    this.foodScale = scale;
    
    // Adjust food to new amount
    while (this.foods.length > this.getMaxFoodCount()) {
      const food = this.foods.pop();
      if (food) {
        this.world.removeBody(food.body);
        this.scene.remove(food.mesh);
      }
    }
    
    this.callbacks.onFoodCountUpdate(this.foods.length);
  }

  // Set mutation rate
  setMutationRate(rate) {
    this.mutationRate = rate;
  }

  // Start simulation
  start() {
    this.simulationRunning = true;
    this.lastTime = performance.now();
  }

  // Pause simulation
  pause() {
    this.simulationRunning = false;
  }

  // Toggle follow mode for selected creature
  toggleFollowCreature() {
    if (!this.selectedCreature) return;
    
    if (this.followedCreature && this.followedCreature.id === this.selectedCreature.id) {
      this.followedCreature = null;
      return false;
    } else {
      this.followedCreature = this.selectedCreature;
      return true;
    }
  }

  // Breed selected creature with random mate
  breedSelectedCreature() {
    if (!this.selectedCreature || this.creatures.length < 2) return null;
    
    // Find a mate (not the same as selected)
    let mate;
    do {
      mate = this.creatures[Math.floor(Math.random() * this.creatures.length)];
    } while (mate.id === this.selectedCreature.id);
    
    const child = this.selectedCreature.breedWith(mate, this.mutationRate);
    
    // Add child to population
    this.creatures.push(child);
    
    // Select the new child
    this.selectCreature(child);
    this.callbacks.onPopulationRender();
    
    return child;
  }

  // Force mutate selected creature
  forceMutateCreature() {
    if (!this.selectedCreature) return false;
    
    const mutationRate = this.mutationRate * 2; // More intense for forced mutation
    this.selectedCreature.mutate(mutationRate);
    
    // Update display
    this.callbacks.onCreatureSelect(this.selectedCreature);
    this.callbacks.onPopulationRender();
    
    return true;
  }

  // Handle window resize
  handleResize(container) {
    if (this.renderer && this.camera) {
      this.camera.aspect = container.offsetWidth / container.offsetHeight;
      this.camera.updateProjectionMatrix();
      this.renderer.setSize(container.offsetWidth, container.offsetHeight);
    }
  }
  
  // Get food spawn rate based on environment
  getFoodSpawnRate() {
    let baseRate = 0.05;
    
    // Adjust based on environment
    switch (this.environmentType) {
      case "plains":
        baseRate = 0.08; // More food in plains
        break;
      case "forest":
        baseRate = 0.07; // Slightly more food in forests
        break;
      case "desert":
        baseRate = 0.03; // Less food in desert
        break;
      case "predators":
        baseRate = 0.04; // Less food with predators
        break;
    }
    
    // Seasonal effects
    if (this.seasonalChanges) {
      // Calculate seasonal modifier (0.5 to 1.5)
      const seasonalMod = 1 + 0.5 * Math.sin(this.environmentCycleTime / this.environmentCyclePeriod * Math.PI * 2);
      baseRate *= seasonalMod;
    }
    
    return baseRate;
  }
  
  // Apply seasonal effects when cycle completes
  applySeasonalEffect() {
    const effects = [
      "drought", // Less food
      "abundance", // More food
      "cold", // Movement penalty
      "optimal", // Growth bonus
      "predation" // Higher danger
    ];
    
    const effect = effects[Math.floor(Math.random() * effects.length)];
    
    switch (effect) {
      case "drought":
        this.environmentSettings.foodDistribution = "sparse";
        break;
      case "abundance":
        this.environmentSettings.foodDistribution = "abundant";
        break;
      case "cold":
        this.environmentSettings.temperature = "cold";
        break;
      case "optimal":
        this.environmentSettings.temperature = "moderate";
        break;
      case "predation":
        this.environmentSettings.predatorPressure = "high";
        break;
    }
    
    // Notify of seasonal change
    if (this.callbacks.onSeasonalChange) {
      this.callbacks.onSeasonalChange(effect);
    }
  }
  
  // Apply environmental effects to creatures
  applyEnvironmentalEffects() {
    // Apply global effects to all creatures
    this.creatures.forEach(creature => {
      // Temperature effects
      if (this.environmentSettings.temperature === "extreme") {
        // Extreme temperatures drain energy faster
        if (Math.random() < 0.1) {
          creature.energy = Math.max(10, creature.energy - 1);
        }
        
        // Creatures with adaptations suffer less
        if (this.environmentType === "desert" && creature.genes.environmentalPreference === "land") {
          // Land creatures handle desert better
          creature.energy += 0.5;
        } else if (this.environmentType === "ocean" && creature.genes.environmentalPreference === "water") {
          // Water creatures thrive in ocean
          creature.energy += 0.5;
        }
      }
      
      // Predator pressure effects
      if (this.environmentSettings.predatorPressure === "high") {
        // Occasionally simulate predator attacks
        if (Math.random() < 0.005) {
          // Larger creatures are less vulnerable
          const escapeChance = creature.genes.size * 0.7 + creature.genes.speed * 0.3;
          
          if (Math.random() > escapeChance) {
            // Failed to escape - take damage
            creature.energy = Math.max(10, creature.energy - 20);
            
            // Visual feedback
            if (creature.meshes && creature.meshes[0]) {
              // Flash red to indicate damage
              const originalColor = creature.meshes[0].material.color.clone();
              creature.meshes[0].material.color.set(0xff0000);
              
              // Reset color after 300ms
              setTimeout(() => {
                if (creature.meshes && creature.meshes[0]) {
                  creature.meshes[0].material.color.copy(originalColor);
                }
              }, 300);
            }
          }
        }
      }
    });
  }
  
  // Apply environment-specific effects to creature movement
  applyEnvironmentToCreature(creature, time) {
    switch (this.environmentType) {
      case "ocean":
        // Buoyancy effect - reduced gravity
        creature.body.gravity.set(0, -4.9, 0);
        
        // Swimming creatures move faster in water
        if (creature.genes.limbType === "swimming") {
          creature.body.velocity.x *= 1.2;
          creature.body.velocity.z *= 1.2;
        } else {
          // Non-swimming creatures move slower in water
          creature.body.velocity.x *= 0.8;
          creature.body.velocity.z *= 0.8;
        }
        break;
        
      case "mountains":
        // Stronger gravity
        creature.body.gravity.set(0, -12, 0);
        
        // Climbing creatures are less affected
        if (creature.genes.limbType === "climbing") {
          creature.body.gravity.set(0, -9, 0);
        }
        break;
        
      case "desert":
        // Normal gravity but higher movement cost
        creature.body.gravity.set(0, -9.82, 0);
        
        // Creatures lose energy faster when moving in desert
        if (creature.body.velocity.length() > 2) {
          creature.energy -= 0.01;
        }
        break;
        
      default:
        // Reset to normal gravity
        creature.body.gravity.set(0, -9.82, 0);
    }
  }
  
  // Get selection pressure based on environment
  getSelectionPressure() {
    let pressure = 0.3; // Default - keep top 30%
    
    // Adjust based on environment type
    switch (this.environmentType) {
      case "desert":
      case "predators":
        pressure = 0.2; // Harsher environments - only top 20% survive
        break;
      case "plains":
      case "forest":
        pressure = 0.4; // More forgiving environments
        break;
    }
    
    // Further modify by competition intensity
    pressure *= (2 - this.environmentSettings.competitionIntensity);
    
    // Ensure reasonable bounds
    return Math.max(0.1, Math.min(0.5, pressure));
  }
  
  // Get adjusted mutation rate based on environmental factors
  getAdjustedMutationRate() {
    let rate = this.mutationRate;
    
    // Increase mutation rate in extreme environments
    if (this.isExtremeEnvironment()) {
      rate *= 1.5;
    }
    
    // Apply environmental mutation stimulus
    rate *= this.environmentSettings.mutationStimulus;
    
    // Generation-based adjustments (higher in early generations)
    if (this.currentGeneration < 5) {
      rate *= 1.2;
    }
    
    // Check if any creatures consumed minerals with evolution boost
    const hasEvolutionBoost = this.creatures.some(c => c.evolutionBoost);
    if (hasEvolutionBoost) {
      rate *= 1.3;
    }
    
    return rate;
  }
  
  // Determine if environment is extreme (high selection pressure)
  isExtremeEnvironment() {
    return this.environmentType === "desert" ||
           this.environmentType === "predators" ||
           this.environmentSettings.temperature === "extreme" ||
           this.environmentSettings.predatorPressure === "high";
  }
  
  // Check if population has low genetic diversity
  checkLowDiversity() {
    if (this.creatures.length < 2) return true;
    
    // Sample a few random gene pairs to check diversity
    const geneNames = ["speed", "strength", "size", "health", "behavior"];
    const sampleSize = Math.min(5, this.creatures.length);
    const samples = [];
    
    // Get random sample of creatures
    for (let i = 0; i < sampleSize; i++) {
      const randIndex = Math.floor(Math.random() * this.creatures.length);
      samples.push(this.creatures[randIndex]);
    }
    
    // Check genetic diversity
    let totalVariance = 0;
    
    for (const gene of geneNames) {
      const values = samples.map(c => c.genes[gene]);
      const mean = values.reduce((a, b) => a + b, 0) / values.length;
      
      // Calculate variance
      const variance = values.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / values.length;
      totalVariance += variance;
    }
    
    // If average variance is below threshold, diversity is low
    return (totalVariance / geneNames.length) < 0.05;
  }
  
  // Create cyclic environment changes
  cyclicEnvironmentChange() {
    const environments = ["plains", "forest", "ocean", "mountains", "desert"];
    const currentIndex = environments.indexOf(this.environmentType);
    
    // Move to next environment type (or cycle back to start)
    const nextIndex = (currentIndex + 1) % environments.length;
    this.setEnvironmentType(environments[nextIndex]);
    
    // Update UI with environment change notification
    if (this.callbacks.onEnvironmentChange) {
      this.callbacks.onEnvironmentChange(this.environmentType);
    }
  }
  
  // Add and update environmental obstacles
  updateEnvironmentalObstacles() {
    // Clear existing obstacles
    this.obstacles.forEach(obstacle => {
      if (obstacle.body) this.world.removeBody(obstacle.body);
      if (obstacle.mesh) this.scene.remove(obstacle.mesh);
    });
    
    this.obstacles = [];
    
    // Skip if using flat terrain
    if (this.environmentSettings.terrain === "flat") return;
    
    // Number of obstacles based on terrain type
    let obstacleCount;
    switch (this.environmentSettings.terrain) {
      case "rocky":
        obstacleCount = 15;
        break;
      case "mountainous":
        obstacleCount = 25;
        break;
      case "hilly":
        obstacleCount = 10;
        break;
      default:
        obstacleCount = 5;
    }
    
    // Create obstacles
    for (let i = 0; i < obstacleCount; i++) {
      this.createObstacle();
    }
  }
  
  // Create a single obstacle
  createObstacle() {
    // Random position in world
    const position = new CANNON.Vec3(
      (Math.random() - 0.5) * this.WORLD_SIZE * 0.8,
      0.5,
      (Math.random() - 0.5) * this.WORLD_SIZE * 0.8
    );
    
    // Random size
    const size = 0.5 + Math.random() * 2;
    
    // Create physics body
    const shape = Math.random() > 0.5 ?
      new CANNON.Box(new CANNON.Vec3(size, size, size)) :
      new CANNON.Sphere(size);
    
    const body = new CANNON.Body({
      mass: 0, // Static obstacle
      position: position,
      shape: shape,
      material: new CANNON.Material({ friction: 0.5, restitution: 0.3 })
    });
    
    this.world.addBody(body);
    
    // Create visual representation
    let geometry;
    if (shape instanceof CANNON.Box) {
      geometry = new THREE.BoxGeometry(size * 2, size * 2, size * 2);
    } else {
      geometry = new THREE.SphereGeometry(size, 16, 16);
    }
    
    const material = new THREE.MeshStandardMaterial({
      color: this.getObstacleColor(),
      roughness: 0.8,
      metalness: 0.2
    });
    
    const mesh = new THREE.Mesh(geometry, material);
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    mesh.position.copy(body.position);
    
    this.scene.add(mesh);
    
    // Store obstacle
    this.obstacles.push({ body, mesh });
  }
  
  // Get color based on environment
  getObstacleColor() {
    switch (this.environmentType) {
      case "plains":
        return 0x8B4513; // Brown
      case "forest":
        return 0x2E8B57; // Forest green
      case "ocean":
        return 0x5F9EA0; // Cadet blue
      case "mountains":
        return 0x808080; // Gray
      case "desert":
        return 0xF4A460; // Sandy brown
      default:
        return 0x808080; // Gray
    }
  }
  
  // Update the visual appearance of the environment
  updateEnvironmentAppearance() {
    // Change ground color based on environment type
    const groundColor = this.getGroundColor();
    
    // Update lighting based on environment
    this.updateEnvironmentLighting();
    
    // If we have a grid helper, update its colors
    if (this.scene && this.scene.children) {
      this.scene.children.forEach(child => {
        if (child instanceof THREE.GridHelper) {
          child.material.color.set(groundColor);
          child.material.vertexColors = false;
        }
      });
    }
    
    // Update scene background color
    if (this.scene) {
      switch (this.environmentType) {
        case "ocean":
          this.scene.background = new THREE.Color(0x1a3c6e); // Deep blue
          this.scene.fog = new THREE.Fog(0x1a3c6e, 20, this.WORLD_SIZE * 0.8);
          break;
        case "desert":
          this.scene.background = new THREE.Color(0xffd7a8); // Light sand color
          this.scene.fog = new THREE.Fog(0xffd7a8, 25, this.WORLD_SIZE);
          break;
        case "mountains":
          this.scene.background = new THREE.Color(0x87ceeb); // Sky blue
          this.scene.fog = new THREE.Fog(0x87ceeb, 15, this.WORLD_SIZE * 0.7);
          break;
        case "predators":
          this.scene.background = new THREE.Color(0x3c1a1a); // Dark red
          this.scene.fog = new THREE.Fog(0x3c1a1a, 10, this.WORLD_SIZE * 0.6);
          break;
        default: // Plains and forest
          this.scene.background = new THREE.Color(0x1a202c); // Dark blue-gray
          this.scene.fog = null;
      }
    }
  }
  
  // Get ground color based on environment
  getGroundColor() {
    switch (this.environmentType) {
      case "plains":
        return 0x7cfc00; // Lawn green
      case "forest":
        return 0x228b22; // Forest green
      case "ocean":
        return 0x1e90ff; // Dodger blue
      case "mountains":
        return 0x708090; // Slate gray
      case "desert":
        return 0xf4a460; // Sandy brown
      case "predators":
        return 0x8b0000; // Dark red
      default:
        return 0x333333; // Dark gray
    }
  }
  
  // Update lighting based on environment
  updateEnvironmentLighting() {
    if (!this.scene) return;
    
    // Find existing lights
    let ambientLight, dirLight;
    
    this.scene.children.forEach(child => {
      if (child instanceof THREE.AmbientLight) {
        ambientLight = child;
      } else if (child instanceof THREE.DirectionalLight) {
        dirLight = child;
      }
    });
    
    // Adjust lighting based on environment
    if (ambientLight && dirLight) {
      switch (this.environmentType) {
        case "desert":
          // Bright, harsh lighting
          ambientLight.intensity = 0.7;
          dirLight.intensity = 1.2;
          dirLight.position.set(10, 30, 10);
          break;
        case "forest":
          // Filtered, dappled lighting
          ambientLight.intensity = 0.4;
          dirLight.intensity = 0.6;
          dirLight.position.set(5, 15, 10);
          break;
        case "ocean":
          // Blue-tinted, watery lighting
          ambientLight.intensity = 0.5;
          ambientLight.color.set(0x6688aa);
          dirLight.intensity = 0.7;
          dirLight.position.set(10, 20, -10);
          break;
        case "mountains":
          // Clear, crisp lighting
          ambientLight.intensity = 0.3;
          dirLight.intensity = 1.0;
          dirLight.position.set(-10, 25, 10);
          break;
        case "predators":
          // Dark, ominous lighting
          ambientLight.intensity = 0.2;
          dirLight.intensity = 0.5;
          dirLight.position.set(0, 15, 5);
          break;
        default: // Plains
          // Standard balanced lighting
          ambientLight.intensity = 0.5;
          ambientLight.color.set(0x404040);
          dirLight.intensity = 0.8;
          dirLight.position.set(10, 20, 10);
      }
    }
  }
}

export default Simulation;

/* File: js/ui.js */

// UI.js - Handles all user interface interactions and rendering

class UI {
  constructor(simulation) {
    this.simulation = simulation;
    this.elements = {};
    this.lineageChart = null;
    
    // Initialize UI elements
    this.initUIElements();
    this.attachEventListeners();
  }
  
  // Find and store all UI elements
  initUIElements() {
    // Main containers
    this.elements.voxelViewer = document.querySelector(".voxel-container");
    this.elements.threeContainer = document.getElementById("three-container");
    this.elements.populationGrid = document.getElementById("population-grid");
    this.elements.loadingOverlay = document.getElementById("loading-overlay");
    this.elements.statsOverlay = document.getElementById("stats-overlay");
    
    // Counters and displays
    this.elements.generationCounter = document.getElementById("generation-counter");
    this.elements.fitnessScore = document.getElementById("fitness-score");
    this.elements.foodCount = document.getElementById("food-count");
    
    // Control buttons
    this.elements.startBtn = document.getElementById("start-btn");
    this.elements.pauseBtn = document.getElementById("pause-btn");
    this.elements.resetBtn = document.getElementById("reset-btn");
    this.elements.breedBtn = document.getElementById("breed-btn");
    this.elements.mutateBtn = document.getElementById("mutate-btn");
    this.elements.followBtn = document.getElementById("follow-btn");
    
    // Input elements
    this.elements.environmentSelect = document.getElementById("environment-type");
    this.elements.populationSizeInput = document.getElementById("population-size");
    this.elements.physicsAccuracyInput = document.getElementById("physics-accuracy");
    this.elements.mutationRateInput = document.getElementById("mutation-rate");
    this.elements.foodAmountInput = document.getElementById("food-amount");
    
    // Selected creature information
    this.elements.selectedCreature = document.getElementById("selected-creature");
    this.elements.creatureAge = document.getElementById("creature-age");
    this.elements.creatureFitness = document.getElementById("creature-fitness");
    this.elements.creatureGeneration = document.getElementById("creature-generation");
    this.elements.creatureSpecies = document.getElementById("creature-species");
    
    // Stat displays
    this.elements.statSpeed = document.getElementById("stat-speed");
    this.elements.statStrength = document.getElementById("stat-strength");
    this.elements.statSize = document.getElementById("stat-size");
    this.elements.statHealth = document.getElementById("stat-health");
    this.elements.statEnergy = document.getElementById("stat-energy");
    this.elements.statAge = document.getElementById("stat-age");
    
    // Gene visualization
    this.elements.speedBar = document.getElementById("speed-bar");
    this.elements.strengthBar = document.getElementById("strength-bar");
    this.elements.sizeBar = document.getElementById("size-bar");
    this.elements.healthBar = document.getElementById("health-bar");
    this.elements.behaviorBar = document.getElementById("behavior-bar");
    this.elements.specializationBar = document.getElementById("specialization-bar");
    this.elements.speedValue = document.getElementById("speed-value");
    this.elements.strengthValue = document.getElementById("strength-value");
    this.elements.sizeValue = document.getElementById("size-value");
    this.elements.healthValue = document.getElementById("health-value");
    this.elements.behaviorType = document.getElementById("behavior-type");
    this.elements.specialization = document.getElementById("specialization");
    
    // Chart
    this.elements.lineageChart = document.getElementById("lineage-chart");
  }
  
  // Attach event listeners to UI elements
  attachEventListeners() {
    // Control buttons
    this.elements.startBtn.addEventListener("click", () => this.startSimulation());
    this.elements.pauseBtn.addEventListener("click", () => this.pauseSimulation());
    this.elements.resetBtn.addEventListener("click", () => this.resetSimulation());
    this.elements.breedBtn.addEventListener("click", () => this.breedSelectedCreature());
    this.elements.mutateBtn.addEventListener("click", () => this.mutateSelectedCreature());
    this.elements.followBtn.addEventListener("click", () => this.toggleFollowCreature());
    
    // Environment select
    this.elements.environmentSelect.addEventListener("change", () => {
      this.simulation.setEnvironmentType(this.elements.environmentSelect.value);
    });
    
    // Physics accuracy
    this.elements.physicsAccuracyInput.addEventListener("input", () => {
      this.simulation.setPhysicsAccuracy(parseInt(this.elements.physicsAccuracyInput.value));
    });
    
    // Food amount
    this.elements.foodAmountInput.addEventListener("input", () => {
      this.simulation.setFoodAmount(parseInt(this.elements.foodAmountInput.value));
    });
    
    // Keyboard shortcuts
    document.addEventListener("keydown", (e) => {
      if (e.code === "Space") {
        e.preventDefault();
        if (this.simulation.simulationRunning) {
          this.pauseSimulation();
        } else {
          this.startSimulation();
        }
      }
      
      if (e.code === "KeyF") {
        e.preventDefault();
        if (this.simulation.selectedCreature) {
          this.toggleFollowCreature();
        }
      }
    });
    
    // Window resize
    window.addEventListener("resize", () => {
      this.simulation.handleResize(this.elements.voxelViewer);
    });
  }
  
  // Initialize the lineage chart
  initLineageChart() {
    const ctx = this.elements.lineageChart.getContext("2d");
    
    this.lineageChart = new Chart(ctx, {
      type: "line",
      data: {
        labels: Array.from({ length: 15 }, (_, i) => `Gen ${i}`),
        datasets: [
          {
            label: "Top Fitness",
            data: Array(15).fill(0),
            borderColor: "#4fd1c5",
            backgroundColor: "rgba(79, 209, 197, 0.1)",
            borderWidth: 2,
            fill: true,
            tension: 0.3
          }
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: {
            display: false
          }
        },
        scales: {
          y: {
            min: 0,
            max: 100,
            grid: {
              color: "rgba(255, 255, 255, 0.1)"
            },
            ticks: {
              color: "rgba(255, 255, 255, 0.7)"
            }
          },
          x: {
            grid: {
              color: "rgba(255, 255, 255, 0.05)"
            },
            ticks: {
              color: "rgba(255, 255, 255, 0.7)"
            }
          }
        },
        elements: {
          point: {
            radius: 0
          }
        }
      }
    });
    
    return this.lineageChart;
  }
  
  // Update chart data
  updateChartData(fitnessHistory, currentGeneration) {
    if (!this.lineageChart) return;
    
    // Shift data if needed
    const labels = Array.from({ length: 15 }, (_, i) => {
      const gen = currentGeneration - (14 - i);
      return `Gen ${gen >= 0 ? gen : ""}`;
    });
    
    // Pad fitness history with zeros if needed
    const paddedFitness = [
      ...Array(Math.max(0, 15 - fitnessHistory.length)).fill(0),
      ...fitnessHistory
    ];
    
    this.lineageChart.data.labels = labels;
    this.lineageChart.data.datasets[0].data = paddedFitness;
    this.lineageChart.update();
  }
  
  // Render population grid
  renderPopulation() {
    if (!this.elements.populationGrid) return;
    
    this.elements.populationGrid.innerHTML = "";
    
    // Sort by fitness
    const sortedCreatures = [...this.simulation.creatures].sort(
      (a, b) => b.fitness - a.fitness
    );
    
    sortedCreatures.forEach((creature) => {
      const color = new THREE.Color(`hsl(${creature.genes.color}, 70%, 50%)`);
      
      const card = document.createElement("div");
      card.className = `creature-card bg-gray-700 rounded-lg p-3 cursor-pointer transition ${
        this.simulation.selectedCreature?.id === creature.id ? "ring-2 ring-teal-400" : ""
      }`;
      
      // Create a simple visual representation for the card
      const visual = document.createElement("div");
      visual.className =
        "h-24 mb-2 flex items-center justify-center rounded bg-gray-800 relative";
      
      // Main body
      const body = document.createElement("div");
      body.className = "absolute w-8 h-8";
      body.style.backgroundColor = `hsl(${creature.genes.color}, 70%, 50%)`;
      body.style.borderRadius =
        creature.genes.bodyShape === "spherical" ? "50%" : "0";
      body.style.transform = `
        translate(-50%, -50%)
        ${
          creature.genes.bodyShape === "slender"
            ? "scaleX(0.7) scaleY(1.4)"
            : ""
        }
        ${
          creature.genes.bodyShape === "elongated"
            ? "scaleX(1.5) scaleY(0.7)"
            : ""
        }
      `;
      
      // Add some limbs based on symmetry and count
      const limbs = [];
      const showLimbs = Math.min(4, creature.genes.limbs);
      const limbColor = `hsl(${(creature.genes.color + 20) % 360}, 70%, 50%)`;
      
      if (creature.genes.symmetry === "radial") {
        for (let i = 0; i < showLimbs; i++) {
          const angle = (i / showLimbs) * Math.PI * 2;
          const x = Math.cos(angle) * 20;
          const y = Math.sin(angle) * 20;
          
          limbs.push(`
            <div class="absolute w-2 h-4" style="
                background-color: ${limbColor};
                left: 50%;
                top: 50%;
                margin-left: -1px;
                margin-top: -2px;
                transform: translate(${x}px, ${y}px) rotate(${angle}rad);
            "></div>
          `);
        }
      } else {
        for (let i = 0; i < showLimbs; i++) {
          const xOffset = i % 2 === 0 ? -15 : 15;
          const yPos = -15 + Math.floor(i / 2) * 15;
          
          limbs.push(`
            <div class="absolute h-2 w-4" style="
                background-color: ${limbColor};
                left: 50%;
                top: 50%;
                margin-left: -8px;
                margin-top: -1px;
                transform: translate(${xOffset}px, ${yPos}px);
            "></div>
          `);
        }
      }
      
      visual.innerHTML = `
        ${limbs.join("")}
        <div class="absolute w-8 h-8" style="
            background-color: ${color.getStyle()};
            left: 50%;
            top: 50%;
            margin-left: -16px;
            margin-top: -16px;
            border-radius: ${
              creature.genes.bodyShape === "spherical"
                ? "50%"
                : "0"
            };
            transform: translate(0, 0)
                ${
                  creature.genes.bodyShape === "slender"
                    ? "scaleX(0.7) scaleY(1.4)"
                    : ""
                }
                ${
                  creature.genes.bodyShape === "elongated"
                    ? "scaleX(1.5) scaleY(0.7)"
                    : ""
                };
        "></div>
      `;
      
      card.appendChild(visual);
      
      // Add creature info
      const info = document.createElement("div");
      info.className = "text-sm";
      info.innerHTML = `
        <div class="flex justify-between mb-1">
            <span class="font-medium">Gen ${
              creature.generation
            }</span>
            <span class="text-xs bg-gray-600 px-1 rounded">${Math.round(
              creature.fitness * 100
            )}%</span>
        </div>
        <div class="flex justify-between text-xs text-gray-400 mb-1">
            <span>${
              creature.speciesId
                ? `Species ${creature.speciesId}`
                : "New"
            }</span>
            <span>Age ${creature.age}</span>
        </div>
        <div class="h-1 w-full bg-gray-600 rounded-full mb-1">
            <div class="h-1 bg-gradient-to-r from-cyan-400 to-blue-500 rounded-full" style="width: ${
              creature.energy
            }%"></div>
        </div>
        <div class="h-1 w-full bg-gray-600 rounded-full">
            <div class="h-1 bg-gradient-to-r from-green-400 to-green-500 rounded-full" style="width: ${Math.min(
              100,
              creature.eaten * 10
            )}%"></div>
        </div>
      `;
      
      card.appendChild(info);
      
      card.addEventListener("click", () => this.simulation.selectCreature(creature));
      this.elements.populationGrid.appendChild(card);
    });
  }
  
  // Update selected creature info
  updateSelectedCreatureInfo(creature) {
    if (!creature) {
      this.elements.selectedCreature.textContent = "None";
      this.elements.statsOverlay.classList.add("hidden");
      return;
    }
    
    this.elements.statsOverlay.classList.remove("hidden");
    
    // Update creature info
    this.elements.selectedCreature.textContent = `Creature #${creature.id
      .toString()
      .padStart(4, "0")}`;
    this.elements.creatureAge.textContent = `Age: ${creature.age}`;
    this.elements.creatureFitness.textContent = `Fitness: ${(
      creature.fitness * 100
    ).toFixed(1)}%`;
    this.elements.creatureGeneration.textContent = `Gen: ${creature.generation}`;
    this.elements.creatureSpecies.textContent = `Species: ${
      creature.speciesId !== null ? creature.speciesId : "New"
    }`;
    
    // Update stats display
    this.elements.statSpeed.textContent = (
      creature.genes.speed * 10
    ).toFixed(1);
    this.elements.statStrength.textContent = (
      creature.genes.strength * 10
    ).toFixed(1);
    this.elements.statSize.textContent = (
      creature.genes.size * 10
    ).toFixed(1);
    this.elements.statHealth.textContent = (
      creature.genes.health * 10
    ).toFixed(1);
    this.elements.statEnergy.textContent = Math.round(
      creature.energy
    );
    this.elements.statAge.textContent = creature.age;
    
    // Update gene visualization
    this.updateGeneVisualization(creature);
    
    // Highlight selected card
    this.highlightSelectedCard();
  }
  
  // Update gene visualization bars
  updateGeneVisualization(creature) {
    if (!creature) return;
    
    // Update progress bars
    this.elements.speedBar.style.width = `${creature.genes.speed * 100}%`;
    this.elements.strengthBar.style.width = `${creature.genes.strength * 100}%`;
    this.elements.sizeBar.style.width = `${creature.genes.size * 100}%`;
    this.elements.healthBar.style.width = `${creature.genes.health * 100}%`;
    this.elements.behaviorBar.style.width = `${((creature.genes.behavior + 1) / 2) * 100}%`;
    
    // Update values
    this.elements.speedValue.textContent = `${(creature.genes.speed * 10).toFixed(1)}`;
    this.elements.strengthValue.textContent = `${(creature.genes.strength * 10).toFixed(1)}`;
    this.elements.sizeValue.textContent = `${(creature.genes.size * 10).toFixed(1)}`;
    this.elements.healthValue.textContent = `${(creature.genes.health * 10).toFixed(1)}`;
    this.elements.behaviorType.textContent =
      creature.genes.behavior > 0
        ? "Aggressive"
        : creature.genes.behavior < 0
        ? "Passive"
        : "Neutral";
    
    // Update specialization
    const spec = creature.getSpecialization();
    this.elements.specializationBar.style.width = `${spec.score * 100}%`;
    this.elements.specialization.textContent =
      spec.trait === "generalist" ? "Generalist" : `${spec.trait} specialist`;
  }
  
  // Highlight the selected creature's card
  highlightSelectedCard() {
    document.querySelectorAll(".creature-card").forEach((card) => {
      if (this.simulation.selectedCreature && 
          card.querySelector(".font-medium").textContent.includes(`Gen ${this.simulation.selectedCreature.generation}`)) {
        card.classList.add("ring-2", "ring-teal-400");
      } else {
        card.classList.remove("ring-2", "ring-teal-400");
      }
    });
  }
  
  // Start simulation
  startSimulation() {
    if (!this.simulation.simulationRunning) {
      this.simulation.start();
      this.elements.startBtn.innerHTML = '<i class="fas fa-play mr-2"></i> Running...';
      this.elements.startBtn.classList.replace("bg-teal-600", "bg-teal-700");
    }
  }
  
  // Pause simulation
  pauseSimulation() {
    this.simulation.pause();
    this.elements.startBtn.innerHTML = '<i class="fas fa-play mr-2"></i> Start Evolution';
    this.elements.startBtn.classList.replace("bg-teal-700", "bg-teal-600");
  }
  
  // Reset simulation
  resetSimulation() {
    this.pauseSimulation();
    
    const populationSize = parseInt(this.elements.populationSizeInput.value);
    this.simulation.initSimulation(populationSize);
  }
  
  // Breed selected creature
  breedSelectedCreature() {
    const child = this.simulation.breedSelectedCreature();
    if (child) {
      this.renderPopulation();
      this.updateSelectedCreatureInfo(child);
    }
  }
  
  // Mutate selected creature
  mutateSelectedCreature() {
    if (this.simulation.forceMutateCreature()) {
      this.updateSelectedCreatureInfo(this.simulation.selectedCreature);
      this.renderPopulation();
    }
  }
  
  // Toggle follow mode for selected creature
  toggleFollowCreature() {
    const isFollowing = this.simulation.toggleFollowCreature();
    
    if (isFollowing) {
      this.elements.followBtn.innerHTML = '<i class="fas fa-eye-slash mr-1"></i> Following';
      this.elements.followBtn.classList.remove("bg-green-600", "hover:bg-green-500");
      this.elements.followBtn.classList.add("bg-green-700", "text-white");
    } else {
      this.elements.followBtn.innerHTML = '<i class="fas fa-eye mr-1"></i> Follow';
      this.elements.followBtn.classList.remove("bg-green-700", "text-white");
      this.elements.followBtn.classList.add("bg-green-600", "hover:bg-green-500");
    }
  }
  
  // Update food count display
  updateFoodCount(count) {
    this.elements.foodCount.textContent = count;
  }
  
  // Update generation counter display
  updateGenerationCounter(generation) {
    this.elements.generationCounter.textContent = generation;
  }
  
  // Update fitness score display
  updateFitnessScore(fitness) {
    this.elements.fitnessScore.textContent = fitness.toFixed(2);
  }
  
  // Set up simulation with callbacks
  setupSimulationCallbacks() {
    // Set up callbacks from simulation to UI
    return {
      onGenerationChange: (gen) => this.updateGenerationCounter(gen),
      onFitnessUpdate: (fitness) => this.updateFitnessScore(fitness),
      onFoodCountUpdate: (count) => this.updateFoodCount(count),
      onPopulationRender: () => this.renderPopulation(),
      onCreatureSelect: (creature) => this.updateSelectedCreatureInfo(creature),
      onChartUpdate: (fitnessHistory) => this.updateChartData(
        fitnessHistory, 
        this.simulation.currentGeneration
      )
    };
  }
  
  // Show/hide loading overlay
  showLoading(show) {
    if (this.elements.loadingOverlay) {
      this.elements.loadingOverlay.style.display = show ? "flex" : "none";
    }
  }
}

export default UI;

/* File: js/utils.js */

// utils.js - Common utility functions

/**
 * Delay execution for specified milliseconds
 * @param {number} ms - Milliseconds to delay
 * @returns {Promise} - Promise that resolves after the delay
 */
export function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

/**
 * Clamp a value between min and max
 * @param {number} value - Value to clamp
 * @param {number} min - Minimum allowed value
 * @param {number} max - Maximum allowed value
 * @returns {number} - Clamped value
 */
export function clamp(value, min, max) {
  return Math.max(min, Math.min(max, value));
}

/**
 * Generate a random color in HSL format
 * @param {number} saturation - Color saturation (0-100)
 * @param {number} lightness - Color lightness (0-100)
 * @returns {string} - HSL color string
 */
export function randomColor(saturation = 70, lightness = 50) {
  const hue = Math.floor(Math.random() * 360);
  return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
}

/**
 * Map a value from one range to another
 * @param {number} value - Value to map
 * @param {number} inMin - Input range minimum
 * @param {number} inMax - Input range maximum
 * @param {number} outMin - Output range minimum
 * @param {number} outMax - Output range maximum
 * @returns {number} - Mapped value
 */
export function mapRange(value, inMin, inMax, outMin, outMax) {
  return ((value - inMin) * (outMax - outMin)) / (inMax - inMin) + outMin;
}

/**
 * Create a throttled version of a function
 * @param {Function} func - Function to throttle
 * @param {number} limit - Throttle time limit in milliseconds
 * @returns {Function} - Throttled function
 */
export function throttle(func, limit) {
  let inThrottle;
  return function() {
    const args = arguments;
    const context = this;
    if (!inThrottle) {
      func.apply(context, args);
      inThrottle = true;
      setTimeout(() => inThrottle = false, limit);
    }
  };
}

/**
 * Format a number with commas as thousands separators
 * @param {number} x - Number to format
 * @returns {string} - Formatted number string
 */
export function numberWithCommas(x) {
  return x.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
}

/**
 * Generate a unique ID
 * @returns {string} - Unique ID
 */
export function generateUniqueId() {
  return '_' + Math.random().toString(36).substr(2, 9);
}

// main.js - Entry point and initialization

// Import inlined: import Simulation from './simulation.js';
// Import inlined: import UI from './ui.js';
// Import inlined: import * as Utils from './utils.js';

// Initialize Vanta.js background when DOM is loaded
document.addEventListener("DOMContentLoaded", function () {
  // Initialize Vanta.js background
  VANTA.GLOBE({
    el: "#vanta-bg",
    mouseControls: true,
    touchControls: true,
    gyroControls: false,
    minHeight: 200.0,
    minWidth: 200.0,
    scale: 1.0,
    scaleMobile: 1.0,
    color: 0x3f83f8,
    backgroundColor: 0x111827,
    size: 1.0
  });
});

// Initialize the application when all components are loaded
document.addEventListener("components-loaded", function() {
  console.log("All components loaded, initializing application...");
  checkCannonLoaded();
});

// Initialize the simulation
function initApp() {
  // Show loading indicator
  const loadingOverlay = document.getElementById("loading-overlay");
  if (loadingOverlay) loadingOverlay.style.display = "flex";
  
  // Get container element
  const voxelViewer = document.querySelector(".voxel-container");
  const threeContainer = document.getElementById("three-container");
  
  // Create config for simulation
  const populationSize = parseInt(document.getElementById("population-size").value);
  const mutationRate = parseInt(document.getElementById("mutation-rate").value);
  const physicsAccuracy = parseInt(document.getElementById("physics-accuracy").value);
  const foodAmount = parseInt(document.getElementById("food-amount").value);
  const environmentType = document.getElementById("environment-type").value;
  
  const config = {
    worldSize: 30,
    foodSize: 1,
    foodEnergy: 50,
    maxFood: 30,
    populationSize,
    mutationRate,
    physicsAccuracy,
    foodAmount,
    environmentType
  };
  
  // Create simulation
  const simulation = new Simulation(config);
  
  // Create UI and connect it to simulation
  const ui = new UI(simulation);
  
  // Set up callbacks from simulation to UI
  simulation.callbacks = ui.setupSimulationCallbacks();
  
  // Initialize physics world
  simulation.initPhysicsWorld(threeContainer);
  
  // Initialize lineage chart
  ui.initLineageChart();
  
  // Initialize simulation with creatures
  simulation.initSimulation(populationSize);
  
  // Set initial values in simulation
  simulation.setMutationRate(mutationRate);
  simulation.setPhysicsAccuracy(physicsAccuracy);
  simulation.setFoodAmount(foodAmount);
  
  // Start animation loop
  simulation.startAnimation();
  
  // Hide loading overlay
  ui.showLoading(false);
  
  console.log("Simulation initialized successfully");
}

// Check if Cannon.js and other dependencies are loaded
function checkCannonLoaded() {
  if (typeof CANNON !== "undefined" &&
      typeof THREE !== "undefined" &&
      typeof Chart !== "undefined") {
    console.log("All dependencies loaded");
    initApp();
  } else {
    console.log("Waiting for dependencies...");
    setTimeout(checkCannonLoaded, 100);
  }
}


// Initialize the application manually since we removed the module script tags
document.addEventListener('DOMContentLoaded', () => {
  if (typeof initApplication === 'function') {
    initApplication();
  }
});
</script>

<!-- Consolidated inline scripts from components -->

/* Inline script from scripts.html */
<script src='https://cdn.jsdelivr.net/npm/chart.js'></script>

/* Inline script from scripts.html */
<script src='https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js'></script>

/* Inline script from scripts.html */
<script src='https://cdn.jsdelivr.net/npm/vanta@0.5.24/dist/vanta.globe.min.js'></script>

/* Inline script from scripts.html */
<script src='https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js'></script>

/* Inline script from scripts.html */
<script src='https://cdn.tailwindcss.com'></script>

/* Inline script from scripts.html */
<script type="module" src="js/main.js"></script>

</body>

</html>
